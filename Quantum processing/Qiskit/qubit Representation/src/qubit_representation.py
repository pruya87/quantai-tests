# -*- coding: utf-8 -*-
"""Qubit representation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RBN1MDGITNHB8p5agUbqVd7kLrTr3R7S
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def bloch_vector(theta, phi):
    """Convert spherical coords to cartesian on Bloch sphere."""
    x = np.sin(theta) * np.cos(phi)
    y = np.sin(theta) * np.sin(phi)
    z = np.cos(theta)
    return np.array([x, y, z])

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plot the Bloch sphere
# Azimuthal angle ax (equator = φ)
u = np.linspace(0, 2 * np.pi, 100)
# Polar angle ax (altitude = θ)
v = np.linspace(0, np.pi, 100)
# This calculates all the sphere points by revolving the u and v vectors
# x=cos(u)sin(v),y=sin(u)sin(v),z=cos(v) ==> spherical (u,v) to cartesian (x,y,z)
x = np.outer(np.cos(u), np.sin(v))
y = np.outer(np.sin(u), np.sin(v))
z = np.outer(np.ones(np.size(u)), np.cos(v))
ax.plot_surface(x, y, z, color='c', alpha=0.1)

# Azimuth circle in XY plane
azimuth_circle = np.linspace(0, phi - 8, 100)
ax.plot(np.cos(azimuth_circle), np.sin(azimuth_circle), 0, color='blue', linestyle='--', label='Azimuth')

# Polar arc in XZ plane (for simplicity, assuming phi=0)
polar_arc_theta = np.linspace(0, theta - 8, 100)
ax.plot(np.sin(polar_arc_theta), 0, np.cos(polar_arc_theta), color='green', linestyle='--', label='Altitude')

# Initial state: |0> north pole (theta=0)
theta = np.pi/2  # 90 degrees, equator
phi = 0

vec = bloch_vector(theta, phi)
point, = ax.plot([vec[0]], [vec[1]], [vec[2]], 'ro', markersize=10)

# Probabilities of measuring |0> and |1>
p0 = (1 + vec[2]) / 2  # z component
p1 = 1 - p0

ax.text2D(0.05, 0.95, f"P(|0⟩)={p0:.2f}\nP(|1⟩)={p1:.2f}", transform=ax.transAxes)

ax.set_xlim([-1,1])
ax.set_ylim([-1,1])
ax.set_zlim([-1,1])
ax.set_box_aspect([1,1,1])
plt.title("Bloch Sphere & Measurement Probabilities")
plt.show()

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plot the Bloch sphere
# Azimuthal angle ax (equator)
u = np.linspace(0, 2 * np.pi, 100)
# Polar angle ax (altitude)
v = np.linspace(0, np.pi, 100)
# This calculates all the sphere points by revolving the u and v vectors
# x=cos(u)sin(v),y=sin(u)sin(v),z=cos(v) ==> spherical (u,v) to cartesian (x,y,z)
x = np.outer(np.cos(u), np.sin(v))
y = np.outer(np.sin(u), np.sin(v))
z = np.outer(np.ones(np.size(u)), np.cos(v))
# Draw the sphere
ax.plot_surface(x, y, z, color='c', alpha=0.1)

# Azimuth circle in XY plane
azimuth_circle = np.linspace(0, phi - 8, 100)
ax.plot(np.cos(azimuth_circle), np.sin(azimuth_circle), 0, color='blue', linestyle='--', label='Azimuth')

# Polar arc in XZ plane (for simplicity, assuming phi=0)
polar_arc_theta = np.linspace(0, theta - 8, 100)
ax.plot(np.sin(polar_arc_theta), 0, np.cos(polar_arc_theta), color='green', linestyle='--', label='Altitude')

ax.set_xlim([-1,1])
ax.set_ylim([-1,1])
ax.set_zlim([-1,1])
ax.set_box_aspect([1,1,1])
plt.title("Bloch Sphere & Measurement Probabilities")
plt.show()